본문은 [SQL 자격검정 실전문제, K data 한국데이터산업진흥원](http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&ejkGb=KOR&barcode=9788988474846) 책 내용을 바탕으로 작성되었습니다.

# 1. 데이터 모델링의 이해

- <strong>발생시점에 따른 엔티티 분류</strong>

1. 기본/키 엔티티(Fundamental Entity, Key Entity)
2. 중심엔티티(Main Entity)
3. 행위엔티티(Active Entity)

- <strong>데이터 모델링이란</strong>

1. 정보시스템을 구축하기 위한 데이터 관점의 업무 분석 기법
2. 현실세계의 데이터에 대해 약속된 표기법에 의해 표현하는 과정
3. 데이터베이스를 구축하기 위한 분석/설계의 과정

- <strong>데이터 모델링 유의점</strong>

1. 중복(Duplication)
2. 비유연성(Inflextiblity) : 데이터의 정의와 사용을 분리
3. 비일관성(Inconsistency)

- <strong>데이터 모델링의 분류</strong>

1. 개념적 데이터 모델링 (높은 추상화 수준)
2. 논리적 데이터 모델링 (업무에 대한 정확한 표현, 높은 재사용성)
3. 물리적 데이터 모델링 (실제 이식을 고려하여, 성능이나 저장 등 물리적인 성격을 고려한 설계)

- <strong>데이터베이스 스키마 구조 3단계</strong>

1. 외부스키마
2. 개념스키마 (가장 높은 추상화 수준의 통합적 표현)
3. 내부스키마

- <strong>ERD 작성 순서</strong>
  엔티티 그리기 > 엔티티 배치 > 엔티티 간 관계 설정 > 관계명 기술 > 관계의 참여도 > 관계의 필수 여부
- <strong>엔티티의 특징</strong>

1. 반드시 해당 업무에서 필요하고, 관리하고자 하는 정보여야 한다.
2. 유일한 식별자에 의해 식별이 가능해야 한다.
3. 영속적으로 존재하는 인스턴스의 집합이어야 한다. (반드시 두 개 이상)
4. 엔티티는 업무 프로세스에 의해 이용되어야 한다.
5. 엔티티는 반드시 속성이 있어야 한다.
6. 엔티티는 다른 엔티티와 최소 한 개 이상의 관계가 있어야 한다.

- <strong>엔티티, 인스턴스, 속성, 속성값의 관계</strong>

1. 한 개의 엔티티는 두 개 이상의 인스턴스의 집합이어야 한다.
2. 한 개의 엔티티는 두 개 이상의 속성을 갖는다.
3. 한 개의 속성은 한 개의 속성값을 갖는다.

# 2. 데이터 모델과 성능

- <strong>데이터 모델링의 순서(성능을 고려한)</strong>

1. 정규화 > 2.용량 산정 > 3.트랜잭션의 유형 파악 > 4.반정규화 > 5.PK/FK조정 > 6.성능관점에서 데이터 모델 검증

- <strong>1차 정규화와 2차 정규화의 차이</strong>

1. 1차 정규화는 중복되는 컬럼을 여러개의 인스턴스로 분리하기 위한 정규화이다.
2. 2차 정규화는 종속성이 낮은 컬럼을 테이블로 만드는 정규화이다.

- <strong>반정규화 대상을 다른 방법으로 처리</strong>

1. 뷰(VIEW) 테이블 : 지나치게 많은 JOIN이 걸려, 데이터를 조회하는 작업이 어려울 경우 "뷰"를 사용한다.
2. 클러스터링 적용 : 대량의 데이터처리나 부분처리에 의해 성능이 저하되는 경우에 "클러스터링"을 적용하거나 "인덱스"를 적용한다.
3. 인덱스의 조정
4. 관계의 반정규화
5. 파티셔닝 : 대량이 데이터는 PK의 성격에 따라 부분적인 테이블로 분리할 수 있다. 즉 "파티셔닝"으로 성능저하를 방지한다.
   (파티셔닝과 클러스터링이 헷갈릴 수 있다. 명확하게 구분하는 방법은, 파티셔닝은 "논리적으로는 하나이지만 물리적으로는 나누는 방법" 으로 기억하면 된다.)

# 3. SQL 기본

- <strong>트랜잭션의 특성</strong>

1. 원자성
   트랜잭션에서 정의된 연산들은 모두 성공적으로 실행되던지 아니면 전혀 실행되지 않은 상태로 남아 있어야 한다. (all or nothing)
2. 일관성
   트랜잭션이 실행되기 전의 데이터베이스 내용이 잘못 되어 있지 않다면 트랜잭션이 실행된 이후에도 데이터베이스의 내용에 잘못이 있으면 안 된다.
3. 고립성
   트랜잭션이 실행되는 도중에 다른 데이터베이스의 내용에 잘못이 있으면 안 된다.
4. 지속성
   트랜잭션이 성공적으로 수행되면 그 트랜잭션이 갱신한 데이터베이스의 내용은 영구적으로 저장된다.

- <strong>연산자의 우선순위</strong>

1. 괄호로 묶은 연산
2. 부정 연산자(NOT)
3. 비교 연산자와 SQL 비교 연산자
4. 논리 연산자 중 AND, OR 의 순으로 처리

- <strong>NULL의 연산</strong>

1. NULL과의 연산은 "NULL을 리턴"
2. NULL과의 비교는 "FALSE를 리턴"
3. 특정 값보다 크다, 적다 라고 표현할 수 없음.

- <strong>정렬시 NULL값</strong>

1. Oracle에서는 NULL값을 가장 큰 값으로 간주하여 오름차순으로 정렬했을 경우에는 가장 마지막에, 내림차순으로 정렬햇을 경우에는 가장 먼저 위치한다.
2. SQLServer(MSSql)에서는 NULL값을 가장 작은 값으로 간주하여 오름차순으로 정렬했을 경우에는 가장 먼저, 내림차순으로 정렬했을 경우에는 가장 마지막에 위치한다.

# 4. SQL 활용

- <strong>셀프 조인(Self Join)이란?</strong>
  동일 테이블 사이의 조인을 말한다. 따라서 FROM 절에 동일 테이블이 두 번 이상 나타난다.
  동일 테이블 사이의 조인을 수행하면 테이블과 칼럼 이름이 모두 동일하기 때문에 식별을 위해 반드시 Alias를 사용해야 한다.
  Self join을 사용해야 하는 경우 : <em>한 테이블 내에서 두 칼럼이 연관 관계가 있는 경우.</em>

- <strong>순수 관계 연산자의 종류</strong>

1. SELECT
2. PROJECT
3. JOIN
4. DIVISION

- <strong>TOP(N) WITH TIES 문</strong>
  상위 3개를 가져오는데, 같은게 있다면 함께 출력한다.

- <strong>CROSS JOIN이란</strong>
  테이블 간 JOIN 조건이 없는 경우 생길 수 있는 모든 데이터의 조합을 말한다. 결과는 양쪽 집합의 M\*N 건의 데이터 조합이 발생한다.

- <strong>연관 서브쿼리(Correlated Subquery)란?</strong>
  서브쿼리가 메인쿼리 컬럼을 포함하고 있는 형태의 서브쿼리

- <strong>Inline View와 Nested Subquery</strong>
  Inline View : 서브쿼리가 FROM 절에 있는 경우를 말한다.
  Nested Subquery : 서브쿼리가 WHERE 절에 있는 경우를 말한다.

.
